# Phase 2.1: Gameplay Polish - Research

**Researched:** 2026-02-07
**Domain:** Canvas text readability, game balance tuning, localStorage persistence
**Confidence:** HIGH (all three areas are well-understood vanilla JS/Canvas patterns)

## Summary

Phase 2.1 addresses three distinct but straightforward improvements to a working vanilla JS + Canvas 2D game: making watch brand names readable on mobile, rebalancing difficulty so positive scores feel like an achievement, and persisting best scores in localStorage.

The brand visibility problem is a Canvas text rendering issue. The current `drawBrandLabel()` renders brand names at ~11px on a 60px watch with no outline or contrast enhancement. On a mobile screen with DPR 2-3, this text is physically tiny and rendered on a moving, rotating object. The fix involves increasing font size, adding a strokeText outline for contrast, and optionally adding a small background pill behind the label.

The difficulty rebalancing is a numbers-tuning exercise. The current parameters (fake penalty -8, real reward +15, miss penalty -5, fake ratio 15%->55%) make positive scores too easy. Multiple levers are available: steeper fake penalties, higher miss penalties, faster difficulty ramp, more aggressive sneaky ratio, and tighter spawn intervals.

localStorage high scores require a simple JSON-serialized persistence layer with try-catch error handling. The pattern is well-established: store a best-score value (or top-N list) using `localStorage.setItem()` with `JSON.stringify()`, load with `JSON.parse()`, and display on start/game-over screens.

**Primary recommendation:** All three changes are small, well-understood modifications to the existing `game.js` file. They can be implemented in a single plan with three logical sections. No new files, libraries, or architectural changes are needed.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Vanilla JS | ES5 (current codebase style) | All game logic | Zero-dependency constraint from PROJECT.md |
| Canvas 2D API | Native browser | Watch rendering, text rendering | Already in use, no alternatives needed |
| localStorage API | Native browser | Score persistence | Universal browser support, 5MB quota is more than sufficient for score data |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| N/A | - | - | No supporting libraries needed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| localStorage | IndexedDB | Overkill for a single score value; localStorage is simpler and universally supported |
| Canvas text stroke | DOM overlay for labels | Adds HTML/CSS complexity to a pure-canvas game; worse performance with rotating elements |
| Manual difficulty tuning | Adaptive difficulty (player-skill-based) | Over-engineering for a 60-second joke game; static tuning is sufficient |

**Installation:** None required. All APIs are native browser.

## Architecture Patterns

### Recommended Project Structure
No structural changes. All modifications happen within `game.js`:
```
game.js  (existing, ~1321 lines â†’ ~1400 lines estimated after changes)
index.html (no changes)
```

### Pattern 1: Enhanced Brand Label with Stroke Outline
**What:** Render watch brand text with a contrasting stroke outline so it remains legible over any watch case color while the watch moves and rotates.
**When to use:** Any time text must be readable on a colored, moving background in Canvas 2D.
**Why this over alternatives:** The game already uses `ctx.fillText()` for brand labels. Adding `ctx.strokeText()` at the same coordinates with a contrasting color is a one-line addition that immediately solves the readability problem. No DOM changes, no extra elements, no performance cost.

**Current code (line 843-849):**
```javascript
function drawBrandLabel(ctx, brand, r, size) {
  ctx.fillStyle = '#333';
  ctx.font = 'bold ' + Math.max(10, size * 0.18) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(brand, 0, r * 0.3);
}
```

**Problem analysis:**
- `WATCH_SIZE = 60` yields `Math.max(10, 60 * 0.18) = 10.8px` font size
- On a 375px-wide iPhone screen, 10.8px text on a rotating 60px circle is nearly unreadable
- `#333` fill on `#f5f0e8` cream dial has decent contrast but no outline means edges blur at small sizes
- No stroke outline means the text has no edge definition against the dial background
- Text is positioned at `r * 0.3` which is in the lower-center of the dial, competing with hour markers

**Recommended fix:**
```javascript
function drawBrandLabel(ctx, brand, r, size) {
  var fontSize = Math.max(11, size * 0.22);
  ctx.font = 'bold ' + fontSize + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // Stroke first (outline), then fill (readable text on any background)
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = '#ffffff';
  ctx.strokeText(brand, 0, r * 0.3);
  ctx.fillStyle = '#333';
  ctx.fillText(brand, 0, r * 0.3);
}
```

**Key details:**
- Font size increased from `0.18` to `0.22` multiplier (~13px for 60px watch, ~16px for 72px golden watch)
- White stroke outline (`#ffffff`) with `lineWidth = 2.5` creates strong edge contrast against both cream dial and colored case
- Stroke BEFORE fill ensures the outline frames the filled text cleanly
- `strokeText` + `fillText` at same coordinates is the standard Canvas text outline technique

**Confidence:** HIGH -- `strokeText()` is a baseline Canvas API available since 2015, supported on all mobile browsers. This is the standard technique for readable text on varied backgrounds in Canvas games.

### Pattern 2: Difficulty Rebalancing via Numeric Tuning
**What:** Adjust existing difficulty parameters to make positive scores significantly harder to achieve.
**When to use:** When the game economy (rewards vs penalties) is too generous.

**Current economy analysis (60-second round):**

At current parameters, a rough model of an average play session:
- Spawns: ~80-100 watches total (1.2s->0.4s interval over 60s with quadratic ramp)
- Real watches: ~55-65 (55-85% are real, depending on time)
- Fake watches: ~25-35 (15-55% fake over time)
- Assume player slashes ~70% of watches they see
- Real slashed: ~40 watches x +15 = +600
- Fake slashed: ~18 watches x -8 = -144
- Missed real: ~20 watches x -5 = -100
- **Net: ~+356** (easy positive score)

Even a mediocre player clearing 50% of watches would land at roughly +150 or higher. The economy is fundamentally too generous because:
1. Real watch reward (+15) is almost 2x the fake penalty (-8)
2. Miss penalty (-5) is trivially small
3. Fake ratio peaks at only 55% -- nearly half of all watches remain safe to slash
4. Combo multiplier amplifies gains but penalties are flat

**Difficulty levers available (from most to least impactful):**

| Lever | Current | Recommended | Impact |
|-------|---------|-------------|--------|
| Fake slash penalty | -8 | -15 to -20 | HIGH -- makes careless slashing very costly |
| Miss penalty (real not slashed) | -5 | -8 to -10 | MEDIUM -- punishes passive play |
| Real watch reward | +15 | +10 | MEDIUM -- reduces baseline income |
| Fake ratio range | 15%->55% | 20%->65% | HIGH -- more traps at all times |
| Sneaky ratio range | 10%->50% | 15%->60% | HIGH -- sneaky fakes appear earlier and more often |
| Speed multiplier | 1.0x->1.4x | 1.0x->1.8x | MEDIUM -- faster watches are harder to read |
| Spawn interval floor | 0.4s | 0.3s | LOW -- already quite fast |
| Combo break penalty | Reset to x1 | Reset to x1 + score penalty | LOW -- adds complexity |

**Recommended rebalancing approach:**
1. Increase fake penalty to **-15** (from -8): Makes slashing a fake very costly
2. Increase miss penalty to **-8** (from -5): Punishes passive play where you just avoid fakes
3. Reduce real reward to **+10** (from +15): Tightens the economy
4. Increase fake ratio to **20%->65%** (from 15%->55%): More traps at all times
5. Increase sneaky ratio to **15%->60%** (from 10%->50%): Harder to tell real from fake
6. Increase speed multiplier to **1.0x->1.8x** (from 1.0x->1.4x): Faster late-game watches

**With recommended parameters, same model:**
- Real slashed: ~35 x +10 = +350
- Fake slashed: ~25 x -15 = -375
- Missed real: ~20 x -8 = -160
- **Net: ~-185** (most players end negative)

Only players who carefully read brands and avoid fakes while slashing most real watches will go positive. This matches the success criterion: "Finishing with a positive score is extremely difficult."

**Confidence:** HIGH -- this is pure arithmetic tuning of existing parameters. The code structure already supports all these values; only constants change.

### Pattern 3: localStorage High Score Persistence
**What:** Save best score to localStorage after each game, display on start and game-over screens.
**When to use:** Any time game data needs to persist across browser sessions without a server.

**Implementation pattern:**
```javascript
// --- High Score Persistence ---
var STORAGE_KEY = 'watchNinja_bestScore';

function loadBestScore() {
  try {
    var stored = localStorage.getItem(STORAGE_KEY);
    if (stored !== null) {
      var parsed = JSON.parse(stored);
      if (typeof parsed === 'number' && isFinite(parsed)) {
        return parsed;
      }
    }
  } catch (e) {
    // localStorage unavailable or corrupted data -- fail silently
  }
  return null;
}

function saveBestScore(score) {
  try {
    var current = loadBestScore();
    if (current === null || score > current) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(score));
      return true; // new best
    }
  } catch (e) {
    // localStorage unavailable -- fail silently
  }
  return false;
}
```

**Key details:**
- Try-catch wraps ALL localStorage operations (handles private browsing, quota exceeded, disabled storage)
- `JSON.parse()` + type validation prevents corrupted data from crashing the game
- Single best score (not top-N list) -- keeps it simple for a joke game
- Returns `null` when no score exists (first play) -- UI can show "Pas encore de record" or similar
- `saveBestScore()` returns boolean indicating if a new record was set -- useful for UI feedback

**Confidence:** HIGH -- localStorage is universally supported, the try-catch pattern is well-documented, and the data volume is trivial (a single number).

### Anti-Patterns to Avoid
- **Unchecked localStorage access:** Always wrap in try-catch. Private browsing on some browsers throws on `setItem`.
- **Storing raw strings without JSON:** Always use `JSON.stringify`/`JSON.parse` even for numbers, for consistency and future extensibility.
- **Adaptive difficulty based on high score:** Over-engineering for a joke game. Static difficulty is fine.
- **Complex leaderboard UI:** A simple "Meilleur score: X" line is sufficient. No need for a scrollable list or name entry.
- **Changing watch size to improve readability:** Increasing `WATCH_SIZE` would change the game feel. Better to improve text rendering within the existing size.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Text outline on canvas | Custom multi-pass text rendering or shadow-based outlines | `ctx.strokeText()` + `ctx.fillText()` at same coordinates | strokeText is the native Canvas API for this exact purpose; shadows add blur that reduces clarity |
| Persistent storage | Custom cookie system or XHR-based persistence | `localStorage.getItem()`/`setItem()` | Built-in, synchronous, zero-dependency, 5MB quota is vast overkill for a single number |
| Difficulty balancing | Dynamic/adaptive difficulty engine | Direct constant adjustments in existing `getDifficulty()` | The quadratic ramp system already works; only the numeric parameters need tuning |

**Key insight:** All three improvements are parameter changes or small additions to existing functions. No new architectural patterns, data structures, or rendering techniques are needed.

## Common Pitfalls

### Pitfall 1: strokeText Before fillText Order
**What goes wrong:** If you call `fillText()` first and then `strokeText()`, the stroke is drawn ON TOP of the fill, covering part of the filled text with the stroke color. The text looks thicker and less crisp.
**Why it happens:** Canvas draws operations in order. The stroke outline has width that overlaps the fill area.
**How to avoid:** Always call `strokeText()` first, then `fillText()` on top. The fill covers the inner portion of the stroke, leaving a clean outline around the edges.
**Warning signs:** Text looks "embossed" or the fill color appears muted/covered.

### Pitfall 2: lineWidth Too Thick for Small Text
**What goes wrong:** A `lineWidth` of 4+ on 11-13px text makes the outline dominate the letterforms, making text LESS readable.
**Why it happens:** `lineWidth` is total stroke width, so half goes inward over the fill area.
**How to avoid:** Use `lineWidth` of 2-3 for text under 16px. The outline should be a subtle halo, not a thick border.
**Warning signs:** Letters look bloated or strokes merge between adjacent characters.

### Pitfall 3: localStorage Quota or Availability Assumptions
**What goes wrong:** Game crashes on `localStorage.setItem()` in Safari private browsing or when storage quota is exceeded.
**Why it happens:** Private browsing mode in some browsers throws `QuotaExceededError` on ANY `setItem` call. Storage can also be disabled by user settings.
**How to avoid:** Wrap ALL localStorage calls in try-catch. The game must work identically without localStorage -- it's a nice-to-have persistence layer, not a required feature.
**Warning signs:** Uncaught exceptions in console during private browsing.

### Pitfall 4: Over-Tuning Difficulty Makes Game Frustrating Instead of Fun
**What goes wrong:** Making penalties so harsh that players feel "cheated" rather than "challenged." The game stops being funny and becomes annoying.
**Why it happens:** Pure math optimization ignores player psychology. A -30 penalty on a sneaky fake that looks identical to a real watch feels unfair.
**How to avoid:** Keep the difficulty brutal but fair: the information (brand name) is always visible if you look carefully. The difficulty comes from time pressure and visual noise, not from impossible-to-read labels. This is why brand visibility MUST be fixed before or alongside difficulty tuning.
**Warning signs:** Playtesters say "that's bullshit" rather than "damn, I need to try again."

### Pitfall 5: Forgetting to Display Best Score on BOTH Screens
**What goes wrong:** Best score is saved but only shown on game-over screen, not on start screen. Or vice versa.
**Why it happens:** The two screen render functions are separate (`renderStart` and `renderGameOver`) and it's easy to add the display to one but forget the other.
**How to avoid:** Load best score into a global variable at game init and after each save. Both render functions read from the same variable.
**Warning signs:** Success criterion explicitly states "displayed on start/game over screens" (plural).

## Code Examples

### Example 1: Enhanced Brand Label with Stroke Outline
```javascript
// Source: Canvas 2D strokeText API (MDN)
// Replaces existing drawBrandLabel() in game.js (line 843)
function drawBrandLabel(ctx, brand, r, size) {
  var fontSize = Math.max(11, size * 0.22);
  ctx.font = 'bold ' + fontSize + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = '#ffffff';
  ctx.strokeText(brand, 0, r * 0.3);
  ctx.fillStyle = '#333';
  ctx.fillText(brand, 0, r * 0.3);
}
```

### Example 2: localStorage Persistence (Load + Save + Init)
```javascript
// Source: localStorage API (MDN), gamedevjs.com patterns
var STORAGE_KEY = 'watchNinja_bestScore';
var bestScore = null; // loaded at init, updated after each game

function loadBestScore() {
  try {
    var stored = localStorage.getItem(STORAGE_KEY);
    if (stored !== null) {
      var parsed = JSON.parse(stored);
      if (typeof parsed === 'number' && isFinite(parsed)) {
        return parsed;
      }
    }
  } catch (e) { /* fail silently */ }
  return null;
}

function saveBestScore(newScore) {
  try {
    if (bestScore === null || newScore > bestScore) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(newScore));
      bestScore = newScore;
      return true; // new record
    }
  } catch (e) { /* fail silently */ }
  return false;
}

// Call at game init:
// bestScore = loadBestScore();

// Call when game ends (in update() when elapsed >= ROUND_DURATION):
// var isNewBest = saveBestScore(score);
```

### Example 3: Displaying Best Score on Start Screen
```javascript
// Added inside renderStart(), after subtitle
if (bestScore !== null) {
  ctx.font = 'bold 16px sans-serif';
  ctx.fillStyle = '#FFD700';
  ctx.textAlign = 'center';
  ctx.fillText('Meilleur score : ' + (bestScore >= 0 ? '+' : '') + bestScore + '\u20AC', canvasWidth / 2, canvasHeight * 0.25 + 70);
}
```

### Example 4: Displaying Best Score on Game Over Screen
```javascript
// Added inside renderGameOver(), after existing stats
if (bestScore !== null) {
  ctx.font = 'bold 18px sans-serif';
  ctx.fillStyle = '#FFD700';
  ctx.textAlign = 'center';
  ctx.fillText('Record : ' + (bestScore >= 0 ? '+' : '') + bestScore + '\u20AC', cx, lineY);
  lineY += lineGap;
}
// If new best was just set, show celebration
if (isNewBest) {
  ctx.font = 'bold 16px sans-serif';
  ctx.fillStyle = '#50e880';
  ctx.fillText('Nouveau record !', cx, lineY);
  lineY += lineGap;
}
```

### Example 5: Rebalanced Difficulty Parameters
```javascript
// Replaces existing getDifficulty() constants
function getDifficulty() {
  var t = Math.min(1, elapsed / ROUND_DURATION);
  var tEased = t * t;
  return {
    spawnInterval: Math.max(0.3, 1.2 - tEased * 0.9),   // 1.2s -> 0.3s (was 0.4s)
    speedMultiplier: 1.0 + t * 0.8,                       // 1.0x -> 1.8x (was 1.4x)
    fakeChance: 0.20 + t * 0.45,                           // 20% -> 65% (was 15%->55%)
    sneakyChance: 0.15 + t * 0.45                           // 15% -> 60% (was 10%->50%)
  };
}

// Adjusted watch values in spawnWatch():
// var watchValue = isGolden ? 50 : (isFake ? -15 : 10);  // was -8/+15
// Adjusted miss penalty in updateWatches():
// score -= 8;  // was -5
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `fillText()` only for labels | `strokeText()` + `fillText()` combo for contrast | Always available (Canvas baseline) | Standard technique for readable text on colored/busy backgrounds |
| Raw `localStorage.setItem()` | Try-catch wrapped with JSON serialization | Always best practice | Prevents crashes in private browsing and edge cases |
| `textRendering: optimizeLegibility` | Not reliably supported on mobile | Ongoing (2026: still NOT Baseline) | Do NOT depend on `textRendering` property for mobile -- stick with strokeText outline instead |

**Deprecated/outdated:**
- `textRendering` property on Canvas: NOT reliably available on mobile browsers as of 2026. Do not use.

## Open Questions

1. **Exact difficulty numbers require playtesting**
   - What we know: The recommended parameters shift the economy from ~+350 average to ~-185 average. This should make positive scores hard.
   - What's unclear: Whether the feel is "brutally fun" or "frustratingly unfair" can only be determined by playing.
   - Recommendation: Implement the recommended numbers as the starting point, then adjust by +/-2 on penalties/rewards after a play session. The important thing is that all the levers are clearly isolated constants, making post-implementation tuning trivial.

2. **Whether to store top-N scores or just best score**
   - What we know: Success criteria says "best scores" (plural could mean best score per player, or top N).
   - What's unclear: Whether a top-5 list adds value for a joke game.
   - Recommendation: Start with a single best score. It's simpler, matches the "beat your record" mechanic, and can be extended to top-N later by storing an array instead of a single number. Over-engineering a leaderboard for a birthday game is wasteful.

3. **Whether brand name position should move**
   - What we know: Currently at `r * 0.3` (lower portion of dial). The watch has hour markers at 12/3/6/9 o'clock positions.
   - What's unclear: Whether repositioning the label slightly higher (e.g., `r * 0.2`) or adding a small semi-transparent background pill would further improve readability.
   - Recommendation: Start with font size increase + stroke outline at the current position. If still hard to read after testing, try `r * 0.2` or a small background pill. The stroke outline alone should be sufficient based on standard Canvas game patterns.

## Sources

### Primary (HIGH confidence)
- [MDN: CanvasRenderingContext2D.strokeText()](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeText) -- API signature, parameter documentation, browser support
- [MDN: CanvasRenderingContext2D.textRendering](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textRendering) -- textRendering property values and browser support (NOT Baseline for mobile)
- Existing codebase `game.js` (1321 lines) -- all current implementations inspected directly

### Secondary (MEDIUM confidence)
- [Gamedev.js: Using local storage for high scores](https://gamedevjs.com/articles/using-local-storage-for-high-scores-and-game-progress/) -- localStorage patterns for game development
- [Fruit Ninja Wiki: Arcade Mode](https://fruitninja.fandom.com/wiki/Arcade_Mode) -- reference implementation of 60-second arcade scoring with penalties
- [Fruit Ninja Wiki: Bonus Points](https://fruitninja.fandom.com/wiki/Bonus_points) -- combo and scoring system design patterns

### Tertiary (LOW confidence)
- [Michael Karen: Save High Scores in Local Storage](https://michael-karen.medium.com/how-to-save-high-scores-in-local-storage-7860baca9d68) -- additional localStorage patterns (consistent with primary sources)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- all native browser APIs, no libraries needed
- Architecture: HIGH -- modifications to existing functions only, patterns verified against MDN
- Pitfalls: HIGH -- well-known Canvas and localStorage edge cases, verified against MDN and multiple sources
- Difficulty tuning: MEDIUM -- math model is sound, but exact "fun" balance requires playtesting

**Research date:** 2026-02-07
**Valid until:** 2026-03-07 (stable domain -- Canvas API and localStorage are not evolving)
