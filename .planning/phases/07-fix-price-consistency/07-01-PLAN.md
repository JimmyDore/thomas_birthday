---
phase: 07-fix-price-consistency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [game.js]
autonomous: true

must_haves:
  truths:
    - "Act 1 card display price (e.g. '47 EUR') is the same number stored as inventory cost and used for profit calculation"
    - "Transition screen 'Depense totale' equals the sum of individual item prices shown in the inventory list"
    - "Act 2 buyer cards show 'Paye: X EUR' where X matches the price the player saw on the Act 1 card"
    - "Act 2 offer prices scale proportionally to realistic purchase costs (10-99 EUR normal, 200-499 EUR golden) instead of clustering around 6-21 EUR"
    - "Combo multiplier gives a purchase discount -- high combos mean lower cost, more room for profit in Act 2"
  artifacts:
    - path: "game.js"
      provides: "Unified price/cost system"
      contains: "cost: Math.round(watch.price"
  key_links:
    - from: "spawnWatch()"
      to: "addToInventory()"
      via: "watch.price becomes inventory[].cost"
      pattern: "cost.*watch\\.price"
    - from: "addToInventory()"
      to: "createBuyerOffer()"
      via: "inventoryItem.cost drives offer calculation"
      pattern: "inventoryItem\\.cost"
    - from: "slashWatch()"
      to: "act1Spending"
      via: "watch.price (or discounted price) accumulates into spending"
      pattern: "act1Spending.*watch\\.price"
---

<objective>
Unify the price system so that the price displayed on Act 1 cards IS the actual purchase cost used throughout the game. Currently there are two disconnected systems: a decorative `watch.price` (10-99 EUR) shown on cards, and a gameplay `watch.value` (always 10/15/50) used for inventory cost and Act 2 calculations. This causes visible mismatches between what the player sees and what the game calculates.

Purpose: Fix the most visible data inconsistency in the buy/sell mechanic -- players see "47 EUR" on a card but Act 2 says "Paye: 10 EUR", breaking immersion and making the economy feel broken.

Output: A single modified game.js where display price = actual cost throughout the entire price data flow.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-fix-price-consistency/07-RESEARCH.md
@game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unify price and cost in spawn, inventory, and slash flow</name>
  <files>game.js</files>
  <action>
    Make `watch.price` the single source of truth for purchase cost. Apply these changes:

    1. **`spawnWatch()` (~line 438-458):** Remove the `watchValue` variable. The `watch.value` property should be derived from `watch.price`:
       - For real watches: `value: price` (positive, 10-99 or 200-499 for golden)
       - For fake watches: `value: -price` (negative, same range as real to maintain visual indistinguishability)
       - Keep `watch.price` as-is (already random 10-99 normal, 200-499 golden)

    2. **`addToInventory()` (~line 740-751):** Change `cost: Math.abs(watch.value)` to `cost: watch.price`. This makes the inventory cost equal to the displayed card price. Do NOT use `Math.abs(watch.value)` anymore.

    3. **`slashWatch()` (~line 753-785):** Reorder so combo discount is applied BEFORE inventory recording:
       - Calculate combo FIRST (move combo++ and getMultiplier before addToInventory)
       - For real (non-fake) watches: compute `discountedCost = Math.round(watch.price / comboMultiplier)` and set `watch.price = discountedCost` BEFORE calling `addToInventory(watch)`. This way the inventory records the discounted cost.
       - Change `act1Spending += Math.abs(watch.value)` to `act1Spending += watch.price` (which is now the discounted cost for reals, or the raw price for fakes since combo resets on fakes).
       - For score: use `score += watch.isFake ? -watch.price : watch.price` (since watch.price is now the discounted cost after combo).
       - Remove the line `watch.value = watch.value * comboMultiplier` (line 770) -- combo now affects cost as a discount, not a score multiplier.

    4. **Floating text (~line 795-815 area):** The floating price text that appears when slashing should show `watch.price` (the cost the player pays). Search for where floating text is created after slashing and ensure it uses `watch.price` not `watch.value`. Look for `spawnFloatingText` or similar calls that display the EUR amount.

    5. **Transition screen item list (~line 1523):** Change `item.price + ' EUR'` to `item.cost + ' EUR'` so the list shows the actual cost paid (which includes combo discount), not the original decorative price. The `item.price` field on inventory items can be kept for reference but `cost` is the source of truth for display.

    IMPORTANT: Do NOT change `watch.value` usage in `createSplitHalves` or particle spawning -- those use it for physics, not economy. Check all references to `watch.value` after your changes and make sure only economy-related ones are updated.

    IMPORTANT: The card sprite is created at spawn time via `createCardSprite(watch)` which renders `watch.price` on the card face. Since we now modify `watch.price` during slashing (combo discount), the card will STILL show the pre-discount price (which is fine -- the card was already spawned). The discounted cost only matters for inventory and spending. No sprite re-render needed.

    IMPORTANT: Keep `watch.price` as the ORIGINAL price on the watch object. Instead of modifying `watch.price` for combo discount, pass the discounted cost to inventory separately. Revised approach:
    - In `slashWatch()`, compute `var purchaseCost = watch.isFake ? watch.price : Math.round(watch.price / comboMultiplier)`
    - Modify `addToInventory` to accept cost as a parameter: `addToInventory(watch, purchaseCost)`
    - In `addToInventory(watch, purchaseCost)`: set `cost: purchaseCost` (instead of `Math.abs(watch.value)`)
    - `act1Spending += purchaseCost`
    - `score += watch.isFake ? -purchaseCost : purchaseCost`
    This avoids mutating `watch.price` and keeps the sprite display correct.
  </action>
  <verify>
    Run `node test-game.mjs` and check:
    1. Screenshots show Act 1 cards with prices in the 10-99 EUR range
    2. In the transition screen screenshot, the individual item prices and "Depense totale" are consistent (total = sum of listed items)
    3. No JS errors in console output
    4. Use `page.evaluate(() => inventory)` to verify that `cost` values are in realistic ranges (10-99 for normal, 200-499 for golden) rather than always 10/15/50
  </verify>
  <done>
    - `addToInventory` stores `cost` from `watch.price` (discounted by combo for reals)
    - `act1Spending` accumulates the same `purchaseCost` values
    - Transition screen shows `item.cost` for each item
    - `score` reflects the purchase cost, not a fixed 10/15/50
    - `watch.value` is no longer used for economy calculations (only for physics/legacy)
  </done>
</task>

<task type="auto">
  <name>Task 2: Rescale Act 2 offer generation for realistic costs</name>
  <files>game.js</files>
  <action>
    Now that inventory costs are realistic (10-99 EUR normal, 200-499 EUR golden), the Act 2 offer generation in `createBuyerOffer()` needs rescaling:

    1. **Golden offers (~line 1183-1186):** Change from fixed range `150 + random(251)` to margin-based: use the same percentage-margin system as real watches but with tighter margins. Golden cost is 200-499, so:
       - Bad offer rate: same as real watches (15% early -> 50% late)
       - Bad offer: -5% to -30% below cost (golden items retain more value)
       - Good offer: +10% to +60% markup early, shrinking to +5% to +20% late
       - Formula: same structure as real watches block but with golden-specific margins
       - `isGoodDeal = offerPrice > inventoryItem.cost` (already correct)

    2. **Fake offers (~line 1187-1190):** Fakes now have cost 10-99 EUR (same as reals in inventory). Change from fixed `5 + random(11)` to a percentage of cost:
       - Offer = 20-60% of cost (always a loss, since you paid full price for a fake)
       - `offerPrice = Math.max(1, Math.round(inventoryItem.cost * (0.20 + Math.random() * 0.40)))`
       - `isGoodDeal = offerPrice > inventoryItem.cost` (will always be false, correct)

    3. **Real watch offers (~line 1191-1209):** The percentage-based margin system is already correct and scale-invariant. No changes needed to the real watch offer logic -- it already uses `inventoryItem.cost * (1 +/- margin)`. With costs now 10-99 instead of always 10, the offers will naturally spread out. Verify the math still works:
       - A 50 EUR watch with 80% markup = 90 EUR offer (good)
       - A 50 EUR watch with -30% discount = 35 EUR offer (bad)
       - These feel reasonable. No changes needed.

    4. **Verify offer display:** The buyer card already shows `card.cost` for "Paye:" and `card.offerPrice` for the offer. Both will auto-correct since inventory.cost is now realistic. No rendering changes needed.
  </action>
  <verify>
    Run `node test-game.mjs` and check:
    1. Act 2 buyer cards show "Paye: X EUR" where X is in realistic range (10-99 for normal watches)
    2. Offer prices are proportional to purchase cost (not always 6-21 EUR)
    3. Game completes without errors
    4. Final profit calculation works correctly
    5. Use `page.evaluate(() => ({ inventory, act2Revenue, act1Spending }))` to verify offer prices make sense relative to costs
  </verify>
  <done>
    - Golden offer generation uses percentage margins relative to golden inventory cost
    - Fake offer generation scales to fake inventory cost (always a loss)
    - Real watch offers naturally scale (no change needed, already percentage-based)
    - Act 2 buyer cards display coherent numbers that match Act 1 prices
    - Full game loop from Act 1 through Act 2 to game over works with consistent prices
  </done>
</task>

</tasks>

<verification>
1. Run `node test-game.mjs` -- full game playthrough completes without JS errors
2. Screenshot 05 (transition): individual item costs and "Depense totale" are numerically consistent
3. Screenshot 07/08 (Act 2): buyer cards show "Paye: X EUR" with X in 10-99 range (not always 10)
4. Screenshot 09 (game over): final profit = act2Revenue - act1Spending, numbers make sense
5. Verify via page.evaluate:
   - `inventory.every(i => i.cost === i.price || i.cost < i.price)` -- cost equals price or is discounted
   - `act1Spending === inventory.reduce((sum, i) => sum + i.cost, 0)` -- spending matches sum of costs
   - Act 2 offers are proportional to costs (no flat 6-21 EUR range)
</verification>

<success_criteria>
- The price shown on every Act 1 card matches the cost stored in inventory
- Transition screen total matches the sum of displayed item costs
- Act 2 "Paye:" values match Act 1 card prices (accounting for combo discount)
- Act 2 offer prices scale with purchase cost (50 EUR watch gets ~25-110 EUR offers, not 6-21 EUR)
- Combo multiplier reduces purchase cost (buying at combo x2 = half price)
- Full game loop plays through without errors or NaN values
</success_criteria>

<output>
After completion, create `.planning/phases/07-fix-price-consistency/07-01-SUMMARY.md`
</output>
