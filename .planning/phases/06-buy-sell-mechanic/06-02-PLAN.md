---
phase: 06-buy-sell-mechanic
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified: [game.js]
autonomous: true

must_haves:
  truths:
    - "Buyer offer cards render with distinct blue/teal styling, brand name, offer price, and directional hints"
    - "Offers target specific unsold inventory items via round-robin mapping"
    - "Swiping RIGHT on a buyer card accepts the offer (splits, coin/penalty sound, revenue updated)"
    - "Swiping LEFT rejects the offer (card flings left, 'Refuse' label)"
    - "Offer margins shrink over Act 2 time (difficulty via margins, not speed)"
  artifacts:
    - path: "game.js"
      provides: "Buyer card rendering, offer generation, swipe direction, accept/reject handlers"
      contains: "drawBuyerCardToCanvas"
  key_links:
    - from: "createBuyerOffer"
      to: "inventory[targetIndex]"
      via: "round-robin picks unsold inventory item for each offer"
      pattern: "targetIndex"
    - from: "getSwipeDirection"
      to: "checkAct2Collisions"
      via: "direction determines accept (right) vs reject (left)"
      pattern: "getSwipeDirection"
    - from: "acceptOffer"
      to: "inventory[].sold = true"
      via: "marks inventory item as sold and records soldFor"
      pattern: "invItem\\.sold.*=.*true"
---

<objective>
Build all Act 2 primitives: buyer card rendering, offer generation with difficulty ramp, swipe direction detection, and accept/reject handlers. These functions are self-contained building blocks that Plan 06-03 will wire into the Act 2 game loop.

Purpose: Separates the "what are buyer cards and how do they work" concern from the "how does Act 2 run" concern. Each function can be understood and debugged in isolation.

Output: game.js with drawBuyerCardToCanvas, createBuyerSprite, createBuyerOffer, getSwipeDirection, checkAct2Collisions, acceptOffer, rejectOffer functions ready to be called by updateAct2/renderAct2 in Plan 03.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-buy-sell-mechanic/06-CONTEXT.md
@.planning/phases/06-buy-sell-mechanic/06-RESEARCH.md
@.planning/phases/06-buy-sell-mechanic/06-01-SUMMARY.md
@game.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Buyer card rendering, sprite caching, and offer generation</name>
  <files>game.js</files>
  <action>
Implement buyer card visuals and offer logic. These are standalone functions -- they do NOT touch the game loop yet.

**A. Buyer card rendering -- `drawBuyerCardToCanvas(offCtx, ox, oy, card)`:**
- Blue/teal card body with gradient: top `#e8f4f8`, bottom `#d0eef6`. Same roundRect, shadow pattern as `drawCardToCanvas` but different colors.
- Border: `#90cad8`, 1px.
- "OFFRE" label at top (~12% height), bold 10px, color `#007782`.
- Brand name centered at ~45% height, bold 12-16px (scale with card width like existing), color `#333333`.
- Offer price at ~70% height, bold 18px. Color: green `#2a7d4f` if `isGoodDeal`, red `#cc3333` if not. Show as `offerPrice + ' EUR'`.
- Directional hints at bottom (~92% height), 9px, color `rgba(0,0,0,0.3)`: left-aligned "< non", right-aligned "oui >".

**B. Buyer card sprite caching -- `createBuyerSprite(card)`:**
- Same pattern as `createCardSprite` but calls `drawBuyerCardToCanvas`. Stores on `card.sprite` and `card.spritePadding`.
- Buyer cards use the same `CARD_WIDTH` and `CARD_HEIGHT` dimensions.

**C. Offer generation -- `createBuyerOffer(inventoryItem, inventoryIndex, t)`:**
- `t` = normalized Act 2 time (0 to 1) for difficulty ramp.
- For real watches: margin ranges from generous (50-120% markup early) to tight (5-30% late). Bad offer rate: 15% early -> 50% late. Bad offers: -10% to -50% below cost.
- For fake watches: offers are always low, 5-15 EUR regardless of time. Fakes in inventory are always sellable but at a loss.
- For golden watches: offers range 150-400 EUR (premium).
- `isGoodDeal` flag: true if `offerPrice > inventoryItem.cost`.
- Return an object with all physics properties (like `spawnWatch`) PLUS `targetIndex`, `brand`, `offerPrice`, `isFake`, `isGolden`, `isGoodDeal`, `isBuyerOffer: true`.
- The card spawns from bottom like Act 1 cards, using the same `spawnWatch`-style physics (random left/right, parabolic arc). Reuse the velocity/gravity calculations from `spawnWatch`.
- Call `createBuyerSprite` on the card before returning it.

**D. Offer-to-inventory mapping variables and helpers:**
- `currentOfferIndex` is already declared in Plan 01. Add `offerPending` boolean to inventory items (set to `false` in `addToInventory`).
- Add `findNextUnsoldItem()` function: iterates from `currentOfferIndex`, wrapping around, to find an item where `sold === false` and `offerPending === false`. Returns the index or `-1` if all pending/sold.
- When an offer is created, set `inventory[targetIndex].offerPending = true`.

Avoid modifying any existing functions. All new code is additive.
  </action>
  <verify>
After adding all functions, open index.html and check browser console for zero syntax errors. The game should still play normally through Act 1 and transition (Act 2 stub unchanged). Manually test in console: `createBuyerOffer({brand:'Montignac',cost:10,isFake:false,isGolden:false,sold:false,offerPending:false}, 0, 0.5)` should return an object with brand, offerPrice, targetIndex, isBuyerOffer:true, and physics properties (vx, vy, gravity).
  </verify>
  <done>drawBuyerCardToCanvas renders blue/teal buyer cards. createBuyerSprite caches them. createBuyerOffer generates offers with difficulty-ramped margins. findNextUnsoldItem does round-robin lookup. No regressions in Act 1.</done>
</task>

<task type="auto">
  <name>Task 2: Swipe direction detection, Act 2 collision handling, and accept/reject functions</name>
  <files>game.js</files>
  <action>
Implement the Act 2 interaction model: directional swipe detection and offer accept/reject handlers.

**E. Swipe direction detection -- `getSwipeDirection(points)`:**
- Requires at least 3 trail points.
- Calculate horizontal displacement (dx) from first to last point.
- Minimum 30px horizontal displacement.
- Horizontal component must be > 0.8x vertical component (to filter out vertical swipes).
- Return `'right'` (accept) or `'left'` (reject) or `null` (ambiguous/vertical).

**F. Act 2 collision detection -- `checkAct2Collisions()`:**
- Same structure as `checkSlashCollisions()` but calls `getSwipeDirection(trailPoints)` first.
- If direction is `null`, return (no clear directional swipe -- treat as a miss, no action).
- For each card hit by the trail: if `direction === 'right'`, call `acceptOffer(card)`. If `'left'`, call `rejectOffer(card)`.
- Only process cards with `isBuyerOffer === true` and `slashed === false`.

**G. `acceptOffer(offerCard)` function:**
- Mark `offerCard.slashed = true`.
- Look up `inventory[offerCard.targetIndex]`, set `sold = true`, `soldFor = offerCard.offerPrice`, `offerPending = false`.
- Add `offerCard.offerPrice` to `act2Revenue`.
- Calculate profit: `offerCard.offerPrice - inventory[offerCard.targetIndex].cost`.
- If profit >= 0: green floating text `'+X EUR'`, `SoundEngine.playCoin(0)`, green particles. If golden: `SoundEngine.playJackpot()`.
- If profit < 0: red floating text showing the loss, `SoundEngine.playPenalty()`, red particles, label "Mauvaise affaire !".
- Create split halves (reuse `createSplitHalves`), spawn particles.
- Remove the card from the `watches` array.

**H. `rejectOffer(offerCard)` function:**
- Mark `offerCard.slashed = true` (to prevent re-detection).
- Set `inventory[offerCard.targetIndex].offerPending = false`.
- Fling card leftward: `offerCard.vx = -400`, `offerCard.vy = -150`.
- Show "Refuse" floating text (white, 14px) at card position.
- Do NOT remove from watches array immediately (let it fly off and get cleaned up by `updateWatches`).
- Play no sound for rejects (silence = neutral action).

All functions are standalone. They will be called by updateAct2/checkAct2Collisions in Plan 03.
  </action>
  <verify>
Open index.html, check console for zero errors. Play through Act 1 and transition -- no regressions. Manually verify in console: `getSwipeDirection([{x:100,y:200},{x:150,y:195},{x:200,y:190}])` should return `'right'`. `getSwipeDirection([{x:200,y:200},{x:150,y:195},{x:100,y:190}])` should return `'left'`. `getSwipeDirection([{x:100,y:200},{x:105,y:100}])` should return `null` (too few points or too vertical).
  </verify>
  <done>getSwipeDirection detects left/right swipes with dead-zone filtering. checkAct2Collisions uses direction to route to accept/reject. acceptOffer marks inventory sold, adds revenue, plays appropriate sound/particles. rejectOffer flings card left with "Refuse" text. All standalone, ready for Act 2 loop integration.</done>
</task>

</tasks>

<verification>
1. Open index.html -- game plays through Act 1 and transition with zero regressions
2. Console: no errors on load or during gameplay
3. Console test: `createBuyerOffer(...)` returns valid offer object with physics + offer properties
4. Console test: `getSwipeDirection(...)` correctly identifies left, right, and null directions
5. All new functions exist as standalone building blocks (not yet wired into game loop)
</verification>

<success_criteria>
- Buyer card rendering function produces blue/teal cards with OFFRE label, brand, price, and directional hints
- Offer generation respects difficulty ramp (generous early, tight late) with proper fake/golden handling
- Swipe direction detection reliably distinguishes left vs right vs ambiguous
- Accept/reject handlers correctly update inventory, revenue, and visual feedback
- Zero regressions in Act 1 gameplay
- All functions ready for Act 2 loop wiring in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/06-buy-sell-mechanic/06-02-SUMMARY.md`
</output>
