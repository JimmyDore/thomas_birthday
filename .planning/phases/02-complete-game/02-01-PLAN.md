---
phase: 02-complete-game
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [game.js]
autonomous: true

must_haves:
  truths:
    - "Opening the game shows a start screen with Thomas's name and a play button, not instant gameplay"
    - "Tapping the play button starts a 60-second countdown timer visible at top center"
    - "Watches spawn faster and move quicker as the timer counts down"
    - "When timer reaches 0, a game over screen appears with final profit and a replay button"
    - "Tapping replay starts a fresh round with score reset to 0 and timer back to 60"
  artifacts:
    - path: "game.js"
      provides: "Game state machine, start screen, timer, difficulty ramp, game over screen, replay"
      contains: "gameState"
      min_lines: 1100
  key_links:
    - from: "gameLoop"
      to: "renderStart / update+render / renderGameOver"
      via: "gameState string dispatch"
      pattern: "gameState === 'start'|gameState === 'playing'|gameState === 'over'"
    - from: "pointerdown handler"
      to: "handleStartTap / handleReplayTap / swipe logic"
      via: "gameState routing in input handler"
      pattern: "gameState === 'start'.*handleStartTap|gameState === 'over'.*handleReplayTap"
    - from: "update(dt)"
      to: "gameState = 'over'"
      via: "elapsed >= ROUND_DURATION check"
      pattern: "elapsed >= ROUND_DURATION"
    - from: "resetGame()"
      to: "all state variables"
      via: "explicit zeroing of score, elapsed, arrays, stats"
      pattern: "resetGame"
    - from: "getDifficulty()"
      to: "spawnWatch()"
      via: "difficulty object with spawnInterval, speedMultiplier, fakeChance"
      pattern: "getDifficulty|diff\\.spawnInterval"
---

<objective>
Add game state machine (start/playing/over), start screen with Thomas's name, 60-second countdown timer, smooth difficulty ramp, game over screen with replay, and stats tracking to the existing game.js.

Purpose: Transform the infinite-loop tech demo into a playable timed arcade round with proper game flow. This is the structural foundation that Plan 02-02 layers humor content onto.
Output: game.js with working start -> play -> game over -> replay cycle, difficulty that ramps over 60 seconds.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-complete-game/02-CONTEXT.md
@.planning/phases/02-complete-game/02-RESEARCH.md
@game.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Game state machine, input routing, start screen, and timer</name>
  <files>game.js</files>
  <action>
  Add a game state machine and start/timer infrastructure to the existing game.js. All additions go into the existing single file.

  **New state variables (add near top, after existing game state section):**
  ```
  var gameState = 'start';  // 'start' | 'playing' | 'over'
  var ROUND_DURATION = 60;  // seconds
  var elapsed = 0;
  var stats = { realSlashed: 0, fakeSlashed: 0, goldenSlashed: 0, maxCombo: 0, totalWatches: 0 };
  ```

  **Modify gameLoop():** Replace the direct `update(dt); render();` calls with state dispatch:
  - `'start'`: call `renderStart()` only (no physics)
  - `'playing'`: call existing `update(dt)` then `render()` (existing behavior)
  - `'over'`: call `renderGameOver()` only (static screen)

  **Modify input handlers:** Gate ALL input on gameState:
  - In `pointerdown`: if `gameState === 'start'`, call `handleStartTap(px, py)` and return. If `gameState === 'over'`, call `handleReplayTap(px, py)` and return. Only proceed with swipe trail logic if `gameState === 'playing'`.
  - In `pointermove`: only process if `gameState === 'playing'` (no trail on screens).
  - Keep `pointerup`/`pointercancel` as-is (they just set `isPointerDown = false`, harmless).

  **Start screen (renderStart function):**
  - Clear canvas, draw same teal gradient background as gameplay (renderBackground())
  - Title text: "Le Vinted des Montres" in white, bold 28px, centered horizontally, at ~25% screen height
  - Subtitle: "Thomas, prouve que tu es le roi !" in white, 18px, centered, below title
  - Draw 4-6 decorative watches floating slowly in background (reuse drawWatch with mock watch objects that rotate slowly -- create a `decorWatches` array populated on state enter, update their rotation each frame). These should be scattered across the screen at fixed positions, slowly rotating but not moving.
  - Play button: rounded rectangle (use existing roundRect helper) centered horizontally at ~60% screen height, 200px wide x 56px tall, white fill with teal text "Jouer". Store button bounds in a `startButton` object (recalculate relative to canvasWidth/canvasHeight each render).
  - Button tap detection: `handleStartTap(px, py)` checks if tap is within startButton bounds. If yes, call `startGame()`.

  **startGame() function:**
  - Call `resetGame()` to clear all state
  - Set `gameState = 'playing'`
  - Set `lastTime = 0` (forces delta time recalculation on next frame)

  **Timer in update(dt):** Add `elapsed += dt;` at the start of update(). When `elapsed >= ROUND_DURATION`, set `gameState = 'over'` and return immediately (skip rest of update).

  **Timer rendering (renderTimer function):** Called in render() after renderScore().
  - Show `Math.ceil(ROUND_DURATION - elapsed)` centered at top of screen
  - Font: bold 28px white
  - When remaining <= 10: text turns red (#ff4444), font goes to 32px
  - When remaining <= 3: pulse effect -- font size = 28 * (1 + (1 - fractionalSecond) * 0.3) where fractionalSecond = `(ROUND_DURATION - elapsed) % 1`

  **Stats tracking:** In the existing `slashWatch()` function, increment `stats.realSlashed` when slashing a real watch, `stats.fakeSlashed` when slashing a fake. Increment `stats.totalWatches` in `spawnWatch()`.

  **Remove auto-start:** The existing code at the bottom calls `initCanvas(); setupInput(); requestAnimationFrame(gameLoop);` which immediately starts gameplay. Keep these calls but since `gameState` starts as `'start'`, the game loop will show the start screen instead of gameplay. No watches spawn during 'start' state because update() only runs during 'playing'.
  </action>
  <verify>
  Open index.html in a browser. Verify:
  1. Start screen appears with title text and "Jouer" button (no watches spawning)
  2. Tapping "Jouer" starts gameplay with timer counting down from 60
  3. Timer turns red at 10 seconds, pulses at 3-2-1
  4. Game freezes at 0 (game over state reached -- screen may be blank for now, that's OK)
  </verify>
  <done>
  Game shows start screen on load, transitions to timed gameplay on tap, timer counts down 60 seconds, game transitions to 'over' state at 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Difficulty ramp, game over screen, and replay</name>
  <files>game.js</files>
  <action>
  Add difficulty ramping during gameplay, the game over screen with score breakdown, and replay functionality.

  **Difficulty ramp (getDifficulty function):**
  ```javascript
  function getDifficulty() {
    var t = Math.min(1, elapsed / ROUND_DURATION);
    var tEased = t * t; // quadratic ease-in: slow start, frantic end
    return {
      spawnInterval: Math.max(0.3, 1.2 - tEased * 0.8),  // 1.2s -> 0.4s
      speedMultiplier: 1.0 + t * 0.4,                      // 1.0x -> 1.4x
      fakeChance: 0.15 + t * 0.4,                          // 15% -> 55%
      sneakyChance: 0.1 + t * 0.4                           // 10% -> 50% of fakes
    };
  }
  ```

  **Modify update() to use dynamic difficulty:** Replace the fixed `SPAWN_INTERVAL` usage with `diff.spawnInterval` from `getDifficulty()`. Call `var diff = getDifficulty();` after the elapsed/timer check. Pass `diff` to `spawnWatch(diff)`.

  **Modify spawnWatch() to accept difficulty parameter:**
  - Change `spawnWatch()` signature to `spawnWatch(diff)`
  - Use `diff.fakeChance` instead of hardcoded `0.4` for fake probability
  - Use `diff.sneakyChance` instead of hardcoded `0.3` for sneaky probability
  - Multiply vx and vy by `diff.speedMultiplier`
  - Use `diff.spawnInterval` instead of `SPAWN_INTERVAL` in update()

  **Game over screen (renderGameOver function):**
  - Clear canvas, draw teal gradient background
  - Header: "Temps ecoul\u00e9 !" in white, bold 28px, centered, at ~15% height
  - Score breakdown (centered, white text, 18px, spaced vertically):
    - "Montres vendues : " + stats.realSlashed
    - "Contrefacons tranch\u00e9es : " + stats.fakeSlashed
    - "Profit final : " + (score >= 0 ? '+' : '') + score + "\u20AC"
  - Replay button: Same style as start button (white rounded rect, teal text "Rejouer"), centered at ~75% height, 200x56px. Store bounds in `replayButton` object.

  **handleReplayTap(px, py):** Check if tap within replayButton bounds. If yes, call `startGame()` (which calls resetGame() and sets state to 'playing').

  **resetGame() function:** Must clear ALL mutable state to prevent stale data on replay:
  ```javascript
  function resetGame() {
    score = 0;
    elapsed = 0;
    spawnTimer = 0;
    watches.length = 0;
    splitHalves.length = 0;
    particles.length = 0;
    floatingTexts.length = 0;
    trailPoints.length = 0;
    isPointerDown = false;
    stats = { realSlashed: 0, fakeSlashed: 0, goldenSlashed: 0, maxCombo: 0, totalWatches: 0 };
    lastTime = 0;
  }
  ```
  NOTE: Do NOT reset combo/comboMultiplier here yet -- those variables don't exist until Plan 02-02 adds them. Just reset what exists.

  **Recalculate button positions on render:** Both startButton and replayButton x/y/w/h should be computed relative to canvasWidth/canvasHeight at the top of their respective render functions, not cached from resize. This ensures they work on any screen size.

  **Important:** Keep the existing `var SPAWN_INTERVAL = 1.2;` line but it becomes unused (the dynamic difficulty replaces it). Leave it for reference or remove it -- either is fine.
  </action>
  <verify>
  Open index.html in a browser. Full test:
  1. Start screen shows with "Jouer" button
  2. Tap "Jouer" -- gameplay begins, timer counts from 60
  3. Early game: watches spawn slowly (~1.2s apart), mostly real, slow movement
  4. Late game (last 15s): watches spawn rapidly (~0.4s), many fakes, faster movement
  5. Timer hits 0 -- game over screen shows with stats and "Rejouer"
  6. Tap "Rejouer" -- fresh round starts (score 0, timer 60, no residual watches)
  7. Play through second round to verify no state leaks from first round
  </verify>
  <done>
  Complete game flow: start screen -> timed gameplay with difficulty ramp -> game over with stats -> replay. Difficulty smoothly increases spawn rate, speed, and fake ratio over 60 seconds. Replay fully resets all state.
  </done>
</task>

</tasks>

<verification>
1. Open index.html -- start screen appears with Thomas's name and decorative watches
2. Tap "Jouer" -- immediate transition to gameplay with 60-second timer
3. Observe difficulty: early game is relaxed, final 15 seconds are frantic with fast-spawning watches
4. Timer visual: white normally, red at 10s, pulses at 3-2-1
5. At 0 seconds: game over screen shows stats (watches slashed, fakes caught, profit)
6. Tap "Rejouer" -- new round, score resets to 0, timer back to 60
7. Complete second round to verify no state leaks
8. Test on different screen sizes (or resize browser) -- buttons remain tappable and centered
</verification>

<success_criteria>
- Game starts on start screen, not immediate gameplay
- Thomas's name visible on start screen
- 60-second timer counts down with visual warnings
- Difficulty ramps: spawn interval 1.2s->0.4s, speed 1x->1.4x, fake ratio 15%->55%
- Game over screen shows score breakdown
- Replay works with full state reset
- No crashes, no residual state between rounds
</success_criteria>

<output>
After completion, create `.planning/phases/02-complete-game/02-01-SUMMARY.md`
</output>
