# Phase 4.1: Dynamics Tuning - Research

**Researched:** 2026-02-08
**Domain:** Canvas 2D game physics tuning (projectile arcs, readability, game feel)
**Confidence:** HIGH

## Summary

This phase tunes physics parameters in a vanilla JS Canvas 2D "Fruit Ninja"-style game so that Vinted-style listing cards fly slowly enough for players to read brand names ("Montignac" vs "Montignak") on mobile, while keeping gameplay satisfying. The entire problem is parameter tuning in a single file (`game.js`, 1240 lines) -- no new systems, no new libraries, no architecture changes.

The current physics create cards that launch too fast (vy up to -2107 px/s at end-game), fly too high above the screen (apex 3700px above launch on an 844px screen), and spend most of their flight time off-screen. The core issue is that `baseVy` scales with screen height at 0.9x plus a 200px constant, creating excessive launch velocities. Combined with a speedMultiplier that reaches 1.8x by end-game, cards blur past the readable zone. Rotation speed (max 0.25 rad/s) is already gentle and is not the primary readability problem.

The fix involves: (1) reducing base launch velocity so cards arc within the screen rather than above it, (2) reducing gravity proportionally (gravity must scale with velocity squared per projectile physics), (3) potentially capping the speed multiplier ramp, and (4) tuning spawn intervals to maintain difficulty feel despite slower cards. This is a parameter-only change -- no structural refactoring needed.

**Primary recommendation:** Reduce `baseVy` to ~`canvasHeight * 0.55 + 100`, reduce `GRAVITY` to ~400, cap `speedMultiplier` at 1.4x, and widen spawn interval floor to 0.5s -- then test on mobile for feel.

## Standard Stack

No new libraries or tools are needed. This phase is pure parameter tuning.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Vanilla JS | ES5 | Game logic | Project constraint: zero dependencies |
| Canvas 2D API | Native | Rendering | Project constraint: no frameworks |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| N/A | - | - | No supporting libraries needed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual parameter tuning | dat.gui/lil-gui debug panel | Would add a dependency; project is zero-dependency. Use browser console for live tweaking instead |

**Installation:** None required.

## Architecture Patterns

### Current Physics Parameter Map

All tunable parameters are in `game.js`. No project structure changes needed.

```
game.js
  Line 71:  SPAWN_INTERVAL = 1.2      (base spawn interval, seconds)
  Line 72:  GRAVITY = 600              (px/s^2, applied to all objects)
  Line 73:  WATCH_SIZE = 60            (watch icon size, used for golden scaling)
  Line 93:  CARD_WIDTH = 80            (card width in CSS pixels)
  Line 94:  CARD_HEIGHT = 110          (card height in CSS pixels)
  Lines 203-211: getDifficulty()       (spawn interval, speed multiplier, fake chance)
  Lines 215-263: spawnWatch()          (launch velocity calculation)
  Line 228:   baseVy formula           (canvasHeight * 0.9 + 200)
  Line 229:   vy formula               (-(baseVy + random * canvasHeight * 0.25) * speedMult)
  Line 225:   vx formula               ((30 + random * 80) * speedMult)
  Line 252:   rotationSpeed            ((random - 0.5) * 0.5)
```

### Pattern 1: Proportional Gravity-Velocity Scaling
**What:** When reducing launch velocity, gravity must be reduced proportionally to maintain the same arc shape. Specifically, if velocity is multiplied by k, gravity should be multiplied by k^2 to keep the same apex height ratio, or by k to keep the same flight time ratio.
**When to use:** Any time launch speeds are changed.
**Key formula:**
```javascript
// Apex height = vy^2 / (2 * gravity)
// Flight time = 2 * vy / gravity
// To halve apex height while keeping arc shape: reduce vy by sqrt(2), reduce gravity by 1
// To keep same apex but slower: reduce both vy and gravity by same factor k
// This keeps apex height = (k*vy)^2 / (2*k*gravity) = k * vy^2 / (2*gravity)
```

### Pattern 2: Console-Based Live Tuning
**What:** Since all physics constants are global vars (not const), they can be modified at runtime via browser console for rapid iteration.
**When to use:** During parameter tuning iteration.
**Example:**
```javascript
// In browser console on mobile (or desktop Chrome devtools with mobile emulation):
GRAVITY = 400;
// Spawn a few watches and observe
// Adjust until feel is right
```

### Pattern 3: Screen-Height-Relative Physics
**What:** Launch velocity should be relative to screen height so cards reach a consistent portion of the screen across devices.
**When to use:** The current code already does this (line 228: `canvasHeight * 0.9`), but the multiplier is too high.
**Example:**
```javascript
// Current (too fast):
var baseVy = canvasHeight * 0.9 + 200;
// Target: cards should reach upper 15-25% of screen at apex
// For canvasHeight=844: apex at ~170px from top
// apex = vy^2 / (2*gravity), launched from y=894 (canvasHeight+50)
// Need vy^2 / (2*g) = 894 - 170 = 724px
// With g=400: vy = sqrt(2*400*724) = sqrt(579200) = 761 px/s
// baseVy = 761 -> canvasHeight * 0.55 + 100 = 844*0.55+100 = 564 (too low)
// Actually: canvasHeight * 0.7 + 150 = 844*0.7+150 = 741 (closer)
```

### Anti-Patterns to Avoid
- **Tuning velocity without adjusting gravity:** Reducing velocity alone makes cards barely rise. Gravity and velocity must be tuned together.
- **Using fixed pixel values instead of screen-relative:** Hard-coded velocities like `vy = -800` break on different screen sizes. Always use `canvasHeight` multiplier.
- **Over-slowing early game to fix late game:** The early game (speedMult=1.0) may already be borderline. The real problem is the 1.8x multiplier at end-game making late-game unreadable. Fix the ramp, not just the base.
- **Reducing spawn rate without reducing speed:** If cards are slower but spawn just as frequently, the screen gets overcrowded. Spawn interval floor must increase proportionally.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Debug slider UI for tuning | Custom HTML slider overlay | Browser console + global vars | All physics constants are already mutable global vars (`var`, not `const`). Console access is immediate. No UI code to write or remove later. |
| Easing curves | Custom bezier implementation | Keep existing `t * t` quadratic ease-in | The existing easing is fine. The problem is the endpoint values, not the curve shape. |
| Screen-size detection | Custom breakpoint system | Existing `canvasHeight` reference in velocity formula | Already implemented correctly; just needs coefficient adjustment. |

**Key insight:** This is purely a parameter tuning phase. The physics engine, spawn system, and difficulty ramp architecture are all correct -- only the numeric values need adjustment. No new code structures are needed.

## Common Pitfalls

### Pitfall 1: Cards Flying Above Screen (Invisible Apex)
**What goes wrong:** Cards launch with so much velocity that they fly far above the visible screen, spend most of their flight time invisible, and only flash through the visible area twice (going up and coming down) at high speed.
**Why it happens:** Current `baseVy = canvasHeight * 0.9 + 200` creates launch velocities of ~960 px/s on a typical phone. With `GRAVITY = 600`, apex height = 960^2 / 1200 = 768px above launch point. Since launch is at y=894 (below screen), apex is at y=126 -- barely on screen. But with speedMultiplier reaching 1.8x, apex goes to y = -1470, which is 1470px ABOVE the top of the screen.
**How to avoid:** Ensure apex height (vy^2 / 2g) keeps the card within the top 15-25% of the visible screen at ALL difficulty levels, including max speedMultiplier.
**Warning signs:** Cards disappearing off the top of the screen during end-game.

### Pitfall 2: Gravity-Velocity Mismatch
**What goes wrong:** Reducing velocity without proportionally reducing gravity makes cards barely rise off the bottom, creating a "popcorn" effect where cards jump up a little and fall right back.
**Why it happens:** Apex height = vy^2 / (2*g). If vy is halved but g stays the same, apex height is quartered.
**How to avoid:** When reducing vy by factor k, reduce gravity by factor k (to maintain flight time) or k^2 (to maintain apex height).
**Warning signs:** Cards not reaching the upper half of the screen.

### Pitfall 3: Speed Multiplier Destroying Readability
**What goes wrong:** Base speed feels good at game start, but the 1.8x multiplier at end-game makes cards unreadable.
**Why it happens:** Current ramp goes from 1.0x to 1.8x linearly. A card moving at 1.8x base speed passes through the readable zone 1.8x faster, reducing reading time from (say) 800ms to 444ms.
**How to avoid:** Cap speedMultiplier at 1.3-1.4x max. Increase difficulty through spawn rate and fake chance rather than raw speed.
**Warning signs:** Cards being readable at t=0 but unreadable at t=50s.

### Pitfall 4: Overcrowded Screen After Slowing Cards
**What goes wrong:** Slower cards + same spawn rate = too many cards on screen at once, overwhelming the player and causing visual clutter.
**Why it happens:** Slower cards spend longer in the visible area. If spawn interval stays at 0.3s minimum, 3-4 cards may be visible simultaneously.
**How to avoid:** Increase minimum spawn interval proportionally. If cards are 30% slower, increase floor from 0.3s to ~0.5s. Also consider that 2-3 simultaneous visible cards is the sweet spot for this game.
**Warning signs:** 4+ cards visible simultaneously, player can't track them all.

### Pitfall 5: Rotation Obscuring Brand Text at Wrong Moment
**What goes wrong:** Even gentle rotation can make text hard to read if the card happens to be at 45 or 90 degrees during the slow apex portion of the arc.
**Why it happens:** Rotation is continuous and random. A card might be sideways exactly when it's moving slowest (apex), which is the best reading window.
**How to avoid:** Current rotation speed (max 0.25 rad/s) is already very gentle -- a full rotation takes ~25 seconds, so cards only rotate ~22 degrees during a typical 1.5s visible window. This is fine. Do NOT increase rotation speed.
**Warning signs:** Cards appearing sideways at apex on repeated plays.

### Pitfall 6: Breaking the "Feel" by Over-Tuning
**What goes wrong:** Making cards too slow destroys the satisfying "fruit ninja" feel. Cards feel floaty, boring, or like shooting at balloons instead of slashing.
**Why it happens:** Over-correcting from "too fast" to "too slow". The satisfaction comes from cards having momentum and the player reacting with speed.
**How to avoid:** Target a visible-area transit time of 1.0-1.5s at game start, 0.7-1.0s at max difficulty. Cards should still feel like they're being "launched" not "floating". Maintain some horizontal velocity for dynamic arcs.
**Warning signs:** Cards feeling like they're in slow motion. No sense of urgency.

## Code Examples

### Current Physics Values (Baseline)

```javascript
// Source: game.js lines 71-73, 203-211, 215-263
// All values verified from current codebase as of 2026-02-08

// Constants
var GRAVITY = 600;        // px/s^2
var CARD_WIDTH = 80;      // CSS pixels
var CARD_HEIGHT = 110;    // CSS pixels

// Difficulty ramp (line 203-211)
function getDifficulty() {
  var t = Math.min(1, elapsed / ROUND_DURATION);  // 0..1 over 60s
  var tEased = t * t;  // quadratic ease-in
  return {
    spawnInterval: Math.max(0.3, 1.2 - tEased * 0.9),  // 1.2s -> 0.3s
    speedMultiplier: 1.0 + t * 0.8,                      // 1.0x -> 1.8x
    fakeChance: 0.20 + t * 0.45                           // 20% -> 65%
  };
}

// Launch velocity (line 228-229)
var baseVy = canvasHeight * 0.9 + 200;
var vy = -(baseVy + Math.random() * canvasHeight * 0.25) * speedMult;

// Horizontal velocity (line 225)
var vx = fromLeft
  ? (30 + Math.random() * 80) * speedMult   // 30-110 px/s
  : -(30 + Math.random() * 80) * speedMult;

// Rotation (line 252)
rotationSpeed: (Math.random() - 0.5) * 0.5  // -0.25 to +0.25 rad/s
```

### Calculated Current Flight Metrics (iPhone 14, 390x844)

```
canvasHeight = 844 CSS pixels

EARLY GAME (t=0, speedMult=1.0):
  baseVy = 844 * 0.9 + 200 = 959.6
  vy_min = -959.6 px/s (slowest launch)
  vy_max = -(959.6 + 211) = -1170.6 px/s (fastest launch)

  Time to apex: 959.6/600 = 1.60s (slow) to 1170.6/600 = 1.95s (fast)
  Apex height above launch: 959.6^2/1200 = 767px (slow) to 1170.6^2/1200 = 1142px (fast)
  Launch point: y = 894 (canvasHeight + 50)
  Apex y-position: 894 - 767 = 127 (slow) to 894 - 1142 = -248 (fast)

  PROBLEM: Even at game start, fastest launches go 248px ABOVE the screen top.

  Total flight time (launch to return): 3.2s (slow) to 3.9s (fast)
  Time in visible area (y < 844): ~2.9s (slow) -- but velocity is HIGH during visible portion

LATE GAME (t=1.0, speedMult=1.8):
  vy_min = -959.6 * 1.8 = -1727 px/s
  vy_max = -1170.6 * 1.8 = -2107 px/s

  Time to apex: 2.88s to 3.51s
  Apex height above launch: 2488px to 3700px
  Apex y-position: 894 - 2488 = -1594 to 894 - 3700 = -2806

  PROBLEM: Cards fly 1600-2800px ABOVE the screen. Completely invisible at apex.
  Cards flash through visible area at ~1700+ px/s -- a card is 110px tall,
  meaning it passes any point in 110/1700 = 0.065s = 65 MILLISECONDS.

  THIS IS UNREADABLE. Humans need ~200ms minimum to recognize a word.
```

### Recommended New Physics Values

```javascript
// TUNED VALUES -- cards arc within visible screen, readable at all difficulties
// Source: Mathematical analysis + game feel principles

var GRAVITY = 400;  // Reduced from 600 -- proportional to velocity reduction

function getDifficulty() {
  var t = Math.min(1, elapsed / ROUND_DURATION);
  var tEased = t * t;
  return {
    spawnInterval: Math.max(0.5, 1.4 - tEased * 0.9),  // 1.4s -> 0.5s (was 1.2->0.3)
    speedMultiplier: 1.0 + t * 0.4,                      // 1.0x -> 1.4x (was 1.0->1.8)
    fakeChance: 0.20 + t * 0.45                           // unchanged
  };
}

// Launch velocity -- cards reach upper 20% of screen at apex
var baseVy = canvasHeight * 0.65 + 100;  // was canvasHeight * 0.9 + 200
var vy = -(baseVy + Math.random() * canvasHeight * 0.15) * speedMult;
// was: canvasHeight * 0.25 random component

// Horizontal velocity -- slightly reduced for readability
var vx = fromLeft
  ? (20 + Math.random() * 60) * speedMult   // was 30-110, now 20-80
  : -(20 + Math.random() * 60) * speedMult;
```

### Projected Flight Metrics With Tuned Values (iPhone 14, 390x844)

```
canvasHeight = 844

EARLY GAME (t=0, speedMult=1.0):
  baseVy = 844 * 0.65 + 100 = 648.6
  vy_min = -648.6 px/s
  vy_max = -(648.6 + 844*0.15) = -(648.6 + 126.6) = -775.2 px/s

  Time to apex: 648.6/400 = 1.62s (slow) to 775.2/400 = 1.94s (fast)
  Apex height above launch: 648.6^2/800 = 526px to 775.2^2/800 = 751px
  Apex y-position: 894 - 526 = 368 (slow) to 894 - 751 = 143 (fast)

  GOOD: Apex stays within visible screen (143-368 from top).

  Velocity at mid-screen (y=422): Using v^2 = vy_init^2 - 2g*(894-422)
    v = sqrt(648.6^2 - 2*400*472) = sqrt(420681 - 377600) = sqrt(43081) = 208 px/s
    At 208 px/s, a 110px card passes a point in 0.53s = 530ms -- READABLE.

  Total visible time: ~2.8s

LATE GAME (t=1.0, speedMult=1.4):
  vy_min = -648.6 * 1.4 = -908 px/s
  vy_max = -775.2 * 1.4 = -1085 px/s

  Apex height above launch: 908^2/800 = 1030px to 1085^2/800 = 1471px
  Apex y-position: 894 - 1030 = -136 to 894 - 1471 = -577

  Still goes above screen at max difficulty, but only by 136-577px (not 2800px).

  Velocity at mid-screen: sqrt(908^2 - 2*400*472) = sqrt(824464 - 377600) = sqrt(446864) = 668 px/s
  Card passes a point in 110/668 = 0.16s = 165ms -- TIGHT but possible.

  However, near apex the velocity is much lower -- cards slow to ~200px/s
  in the top 30% of screen, giving ~550ms reading window.

  Total visible time: ~2.2s

  ACCEPTABLE: Late game is harder but still readable near apex.
  Difficulty comes from faster spawns and more fakes, not from unreadable speed.
```

### Complete Parameter Change Summary

```javascript
// BEFORE -> AFTER for each parameter:

// game.js line 72:
var GRAVITY = 600;  // -> 400

// game.js line 207:
spawnInterval: Math.max(0.3, 1.2 - tEased * 0.9)
// -> Math.max(0.5, 1.4 - tEased * 0.9)

// game.js line 208:
speedMultiplier: 1.0 + t * 0.8
// -> 1.0 + t * 0.4

// game.js line 228:
var baseVy = canvasHeight * 0.9 + 200;
// -> canvasHeight * 0.65 + 100

// game.js line 229:
var vy = -(baseVy + Math.random() * canvasHeight * 0.25) * speedMult;
// -> -(baseVy + Math.random() * canvasHeight * 0.15) * speedMult

// game.js lines 224-226:
var vx = fromLeft
  ? (30 + Math.random() * 80) * speedMult
  : -(30 + Math.random() * 80) * speedMult;
// -> (20 + Math.random() * 60) * speedMult  (both directions)

// game.js line 252 (rotation) -- KEEP AS-IS:
rotationSpeed: (Math.random() - 0.5) * 0.5  // Already gentle enough
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Screen-height * 0.9 launch velocity | Screen-height * 0.65 (proposed) | This phase | Cards stay within visible screen at all difficulties |
| speedMultiplier up to 1.8x | Cap at 1.4x (proposed) | This phase | Late-game cards remain readable; difficulty via spawn rate and fakes instead |
| GRAVITY=600 with high velocity | GRAVITY=400 with proportionally lower velocity | This phase | Same arc shape, slower motion, longer visible time |
| Spawn interval floor 0.3s | Floor 0.5s (proposed) | This phase | Prevents screen overcrowding with slower cards |

**Deprecated/outdated:**
- `speedMultiplier: 1.0 + t * 0.8` (1.8x max): Designed for small circle watches where readability was not a concern. With text-bearing cards, this multiplier makes brand names unreadable at late game.

## Open Questions

1. **Exact parameter values require playtesting**
   - What we know: The mathematical analysis gives a strong starting point (baseVy ~0.65, gravity ~400, speedMult max ~1.4)
   - What's unclear: Whether these exact values "feel right" subjectively on mobile. The math guarantees readability, but game feel is subjective.
   - Recommendation: Implement the calculated values as first iteration. Test on physical mobile device. Adjust +/- 10-15% based on feel. The math constrains the range; feel determines the exact point within that range.

2. **Whether horizontal velocity (vx) matters for readability**
   - What we know: vx is relatively small (30-110 px/s) compared to vy (~650-1100 px/s). It creates lateral drift but doesn't dominate readability.
   - What's unclear: Whether reducing vx is needed at all, or if vy reduction alone fixes readability.
   - Recommendation: Make a modest vx reduction (30-110 -> 20-80) as proposed but this is lower priority than vy/gravity changes. Can be reverted if arcs feel too vertical.

3. **Miss penalty timing with slower cards**
   - What we know: Slower cards spend more time on screen, giving players more time to slash them. The miss penalty (-8 EUR) fires when a card falls below screen unslashed.
   - What's unclear: Whether the miss penalty economy still feels fair if cards are visible longer (easier to not miss).
   - Recommendation: Keep miss penalty as-is for now. The economy was balanced in Phase 2.1 and the fake chance ramp (20% -> 65%) is the primary difficulty driver, not misses.

## Sources

### Primary (HIGH confidence)
- `game.js` source code -- Direct inspection of all physics constants, difficulty ramp, spawn system, and velocity formulas (1240 lines, read in full)
- `.planning/phases/04-vinted-cards/04-VERIFICATION.md` -- Phase 4 verification confirming card rendering is correct and speed is the isolated issue
- `.planning/phases/04-vinted-cards/04-02-SUMMARY.md` -- Documents the user-reported speed issue that triggered this phase
- `.planning/STATE.md` -- Current project state and accumulated decisions

### Secondary (MEDIUM confidence)
- Projectile physics formulas (apex height = vy^2/2g, flight time = 2*vy/g) -- Standard physics, verified by calculation
- [NN/G mobile reading speed research](https://www.nngroup.com/articles/mobile-content/) -- ~200-250 WPM reading speed on mobile, ~30ms overhead per word vs desktop
- [Fruit Ninja gravity-velocity relationship](https://developers-codex.hashnode.dev/slicing-through-code-how-i-built-fruit-ninja) -- "gravity needs to be increased along with velocity; otherwise, the fruit will fly off the screen"
- [GameMaker Fruit Ninja arcing discussion](http://gmc.yoyogames.com/index.php?showtopic=537300) -- Gravity-velocity proportional scaling for arc maintenance

### Tertiary (LOW confidence)
- Subjective "game feel" recommendations (1.0-1.5s visible time at start, 0.7-1.0s at max difficulty) -- Based on general game design experience, not verified against this specific game
- 500ms minimum for comfortable brand name reading in game context -- Extrapolated from reading research (200-250ms word recognition + mobile overhead + game distraction factor)

## Metadata

**Confidence breakdown:**
- Current physics values: HIGH -- Read directly from game.js source code
- Flight time calculations: HIGH -- Standard projectile physics formulas applied to actual code values
- Recommended new values: MEDIUM -- Mathematically sound but require playtesting for subjective feel
- Game feel guidance: LOW -- Based on general game design principles, not empirically tested

**Research date:** 2026-02-08
**Valid until:** Until phase is implemented (parameter values are specific to this codebase state)
